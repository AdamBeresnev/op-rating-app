package views

import (
	"fmt"
	"github.com/AdamBeresnev/op-rating-app/internal/bracket"
	"github.com/google/uuid"
)

templ BracketRow(title string, titleClass string, roundNums []int, rounds map[int][]bracket.Match, entryMap map[uuid.UUID]bracket.Entry, nextMatchID *uuid.UUID) {
	if len(roundNums) > 0 {
		<div>
			<h2 class={ "text-xl font-bold mb-4", titleClass }>{ title }</h2>
			<div class="flex flex-row gap-8 pb-4">
				for _, roundNum := range roundNums {
					<div class="flex flex-col min-w-[250px]">
						<h3 class="text-center text-gray-400 font-bold mb-4">Round { fmt.Sprint(roundNum) }</h3>
						<div class="flex flex-col justify-around flex-1">
							for _, match := range rounds[roundNum] {
								{{ isActionable := nextMatchID != nil && *nextMatchID == match.ID }}
								<div
									class="py-2 w-full match-container"
									data-match-id={ match.ID.String() }
									data-bracket-side={ string(match.BracketSide) }
									if isActionable {
										data-actionable="true"
									}
									if match.WinnerNextMatchID != nil {
										data-winner-next={ match.WinnerNextMatchID.String() }
									}
									if match.WinnerNextSlot != nil {
										data-next-slot={ fmt.Sprint(*match.WinnerNextSlot) }
									}
								>
									@MatchCard(match, entryMap, nextMatchID)
								</div>
							}
						</div>
					</div>
				}
			</div>
		</div>
	}
}

templ TournamentView(t *bracket.Tournament, entries []bracket.Entry, matches []bracket.Match, nextMatchID *uuid.UUID) {
	{{ data := PrepareBracketData(entries, matches) }}
	@AppLayout(t.Name) {
		<div class="container mx-auto p-4">
			<h1 class="text-3xl font-bold mb-2">{ t.Name }</h1>
			<div class="text-gray-400 mb-8">
				<span class="bg-gray-800 px-2 py-1 rounded text-sm">{ string(t.Status) }</span>
				<span class="ml-2 text-sm">Type: { string(t.Type) }</span>
			</div>
			// God bless Alpine, this would've been so much worse in vanilla JS
			<div
				class="h-[calc(100vh-200px)] w-full relative overflow-hidden border border-slate-700 rounded-lg bg-slate-900/50 cursor-grab"
				x-data="bracketViewer()"
				x-ref="viewport"
				@mousedown="start"
				@touchstart="start"
				@mousemove="move"
				@touchmove="move"
				@mouseup="end"
				@touchend="end"
				@mouseleave="end"
				@wheel.prevent="zoom"
				:class="cursorClass"
			>
				// Canvas controls
				<div class="absolute top-4 right-4 z-10 flex items-center gap-2 bg-slate-800/90 backdrop-blur p-2 rounded border border-slate-700 shadow-lg">
					<button @click.stop="zoomOut" class="w-8 h-8 flex items-center justify-center bg-slate-700 rounded hover:bg-slate-600 text-white transition-colors" title="Zoom Out">
						<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line></svg>
					</button>
					<span x-text="Math.round(scale * 100) + '%'" class="text-xs font-mono text-slate-300 w-12 text-center select-none"></span>
					<button @click.stop="zoomIn" class="w-8 h-8 flex items-center justify-center bg-slate-700 rounded hover:bg-slate-600 text-white transition-colors" title="Zoom In">
						<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
					</button>
					<div class="w-px h-4 bg-slate-600 mx-1"></div>
					<button @click.stop="reset" class="px-3 h-8 bg-slate-700 rounded hover:bg-slate-600 text-white text-xs font-medium transition-colors" title="Reset View">Reset</button>
				</div>
				<div
					class="origin-top-left absolute will-change-transform"
					x-ref="bracketContent"
					:style="`transform: translate(${x}px, ${y}px) scale(${scale})`"
				>
					<svg class="absolute inset-0 w-full h-full pointer-events-none z-0" overflow="visible" x-html="svgContent"></svg>
					<div class="p-8 min-w-max z-10 relative flex flex-row flex-nowrap items-center gap-16" style="display: flex; flex-direction: row; flex-wrap: nowrap; align-items: center; gap: 4rem;">
						// Split winners/losers brackets into one column, grandfinals into another column
						<div class="flex flex-col space-y-12">
							@BracketRow("Winners Bracket", "text-green-400", data.WBRoundNums, data.WBRounds, data.EntryMap, nextMatchID)
							@BracketRow("Losers Bracket", "text-orange-400", data.LBRoundNums, data.LBRounds, data.EntryMap, nextMatchID)
						</div>
						if len(data.FinalRoundNums) > 0 {
							<div class="flex flex-col justify-center" x-ref="finalsColumn">
								@BracketRow("Finals", "text-yellow-400", data.FinalRoundNums, data.FinalRounds, data.EntryMap, nextMatchID)
							</div>
						}
					</div>
				</div>
			</div>
			<script>
				document.addEventListener('alpine:init', () => {
					Alpine.data('bracketViewer', () => ({
						scale: 1,
						panning: false,
						pinching: false,
						x: 0,
						y: 0,
						startX: 0,
						startY: 0,
						lastDist: 0,
						svgContent: '',

						init() {
							this.$nextTick(() => {
                                this.alignFinals();
								this.drawLines();
                                this.focusActiveMatch();
								window.addEventListener('resize', () => {
                                    this.alignFinals();
                                    this.drawLines();
                                    this.constrain();
                                });
								// Re-draw after a short delay to ensure layout stability
								setTimeout(() => {
                                    this.alignFinals();
                                    this.drawLines();
                                    this.focusActiveMatch();
                                }, 100);
							});
						},

                        focusActiveMatch() {
                            const active = this.$root.querySelector('[data-actionable="true"]');
                            if (active) {
                                const container = this.$refs.viewport;
                                const content = this.$refs.bracketContent;
                                
                                let el = active;
                                let unscaledX = 0;
                                let unscaledY = 0;
                                
                                while (el && el !== content) {
                                    unscaledX += el.offsetLeft;
                                    unscaledY += el.offsetTop;
                                    el = el.offsetParent;
                                }

                                const finalsCol = this.$refs.finalsColumn;
                                if (finalsCol && finalsCol.contains(active)) {
                                    const transform = finalsCol.style.transform; // e.g. "translateY(123px)"
                                    const match = transform.match(/translateY\(([-0-9.]+)px\)/);
                                    if (match && match[1]) {
                                        unscaledY += parseFloat(match[1]);
                                    }
                                }

                                const activeW = active.offsetWidth;
                                const activeH = active.offsetHeight;
                                const contentCenterX = unscaledX + (activeW / 2);
                                const contentCenterY = unscaledY + (activeH / 2);

                                this.scale = 1;

                                const newX = (container.clientWidth / 2) - contentCenterX;
                                const newY = (container.clientHeight / 2) - contentCenterY;

                                this.x = newX;
                                this.y = newY;
                                
                                this.constrain();
                            } else {
                                this.fitToScreen();
                            }
                        },

						// Default view if there's no active match to focus on
                        fitToScreen() {
                            const container = this.$refs.viewport;
                            const content = this.$refs.bracketContent;
                            if (!container || !content) return;

                            const cw = container.clientWidth;
                            const ch = container.clientHeight;
                            const bw = content.scrollWidth;
                            const bh = content.scrollHeight;
                            const padding = 50;

                            const scaleX = (cw - padding * 2) / bw;
                            const scaleY = (ch - padding * 2) / bh;
                            
                            let newScale = Math.min(scaleX, scaleY, 1); 
                            this.scale = Math.max(0.2, newScale); 

                            this.x = (cw - bw * this.scale) / 2;
                            this.y = (ch - bh * this.scale) / 2;
                        },

						// Infinite canvas is horrible UX, so we constrain the user from going into the infinite abyss
                        constrain() {
                            const container = this.$refs.viewport;
                            const content = this.$refs.bracketContent;
                            
                            if (!container || !content) return;

                            const cw = container.clientWidth;
                            const ch = container.clientHeight;
                            const bw = content.scrollWidth;
                            const bh = content.scrollHeight;
                            
                            const padding = 50;
                            
                            const sw = bw * this.scale;
                            const sh = bh * this.scale;
                            
                            // Horizontal
                            if (sw < cw) {
                                this.x = (cw - sw) / 2;
                            } else {
                                const minX = cw - sw - padding;
                                const maxX = padding;
                                this.x = Math.min(maxX, Math.max(this.x, minX));
                            }
                            
                            // Vertical
                            if (sh < ch) {
                                this.y = (ch - sh) / 2;
                            } else {
                                const minY = ch - sh - padding;
                                const maxY = padding;
                                this.y = Math.min(maxY, Math.max(this.y, minY));
                            }
                        },

						// This was painful
						// Center the finals not in the middle of the column, but in the middle of the winner's and loser's finals
                        alignFinals() {
                            const finalsCol = this.$refs.finalsColumn;
                            if (!finalsCol) return;

                            // Reset transform to read the position
							// This was also painful
                            finalsCol.style.transform = '';

                            const containers = Array.from(this.$root.querySelectorAll('[data-match-id]'));
                        
                            const grandFinal = containers.find(el => el.dataset.bracketSide === 'finals');

                            // Find inputs to the grand final by looking for matches that point TO the grand final
                            let winnersFinal = null;
                            let losersFinal = null;

                            if (grandFinal) {
                                const gfId = grandFinal.dataset.matchId;
                                winnersFinal = containers.find(el => el.dataset.winnerNext === gfId && el.dataset.bracketSide === 'winners');
                                losersFinal = containers.find(el => el.dataset.winnerNext === gfId && el.dataset.bracketSide === 'losers');
                            }

                            if (winnersFinal && losersFinal && grandFinal) {
                                const rectW = winnersFinal.getBoundingClientRect();
                                const rectL = losersFinal.getBoundingClientRect();
                                const rectGF = grandFinal.getBoundingClientRect();

                                const centerW = rectW.top + rectW.height / 2;
                                const centerL = rectL.top + rectL.height / 2;
                                const targetCenterY = (centerW + centerL) / 2;
                                
                                const currentCenterY = rectGF.top + rectGF.height / 2;
                                // Evil scaling
                                const offset = (targetCenterY - currentCenterY) / this.scale;

                                finalsCol.style.transform = `translateY(${offset}px)`;
                            }
                        },

						drawLines() {
							const containers = this.$root.querySelectorAll('[data-match-id]');
							const map = new Map();
							containers.forEach(el => map.set(el.dataset.matchId, el));

							const rootRect = this.$refs.bracketContent.getBoundingClientRect();
							const s = this.scale;
							
							let newSvgContent = '';

							containers.forEach(source => {
								const draw = (targetId) => {
									if (!targetId || !map.has(targetId)) return;
									const target = map.get(targetId);
									
									const sourceRect = source.getBoundingClientRect();
									const targetRect = target.getBoundingClientRect();
									
									let yOffsetRatio = 0.5;
									if (source.dataset.nextSlot === '1') yOffsetRatio = 0.25;
									else if (source.dataset.nextSlot === '2') yOffsetRatio = 0.75;

									// Calculate coords in unscaled SVG space
									const x1 = (sourceRect.right - rootRect.left) / s;
									const y1 = (sourceRect.top + sourceRect.height/2 - rootRect.top) / s;
									const x2 = (targetRect.left - rootRect.left) / s;
									const y2 = (targetRect.top + (targetRect.height * yOffsetRatio) - rootRect.top) / s;
									
									// Edge case for grandfinals so the bracket lines break properly and don't look ass
									const midX = x2 - Math.min((x2 - x1) / 2, 40);
									
									const color = '#94a3b8';
									newSvgContent += `<path d="M ${x1} ${y1} L ${midX} ${y1} L ${midX} ${y2} L ${x2} ${y2}" fill="none" stroke="${color}" stroke-width="2" opacity="0.6" />`;
								};

								draw(source.dataset.winnerNext);
							});
							
							this.svgContent = newSvgContent;
						},

						get cursorClass() {
							return this.panning ? 'cursor-grabbing' : 'cursor-grab';
						},

						start(e) {
							if (e.type === 'mousedown' && e.button !== 0) return;

							if (e.touches && e.touches.length === 2) {
								this.panning = false;
								this.pinching = true;
								this.lastDist = Math.hypot(
									e.touches[0].clientX - e.touches[1].clientX,
									e.touches[0].clientY - e.touches[1].clientY
								);
								return;
							}

							this.panning = true;
							const clientX = e.touches ? e.touches[0].clientX : e.clientX;
							const clientY = e.touches ? e.touches[0].clientY : e.clientY;
							this.startX = clientX - this.x;
							this.startY = clientY - this.y;
						},
						move(e) {
							if (this.pinching) {
								if (!e.touches || e.touches.length !== 2) return;
								if (e.cancelable) e.preventDefault();

								const dist = Math.hypot(
									e.touches[0].clientX - e.touches[1].clientX,
									e.touches[0].clientY - e.touches[1].clientY
								);
								
								if (dist < 5 || this.lastDist < 5) return;

								const rect = this.$refs.viewport.getBoundingClientRect();
								const midX = ((e.touches[0].clientX + e.touches[1].clientX) / 2) - rect.left;
								const midY = ((e.touches[0].clientY + e.touches[1].clientY) / 2) - rect.top;

								const ratio = dist / this.lastDist;
								const newScaleRaw = this.scale * ratio;
								const newScale = Math.min(Math.max(0.2, newScaleRaw), 5);
								
								this.x = midX - ((midX - this.x) / this.scale) * newScale;
								this.y = midY - ((midY - this.y) / this.scale) * newScale;
								this.scale = newScale;
								this.lastDist = dist;
								
								this.constrain();
								return;
							}

							if (!this.panning) return;
							if (e.cancelable) e.preventDefault();
							const clientX = e.touches ? e.touches[0].clientX : e.clientX;
							const clientY = e.touches ? e.touches[0].clientY : e.clientY;
							this.x = clientX - this.startX;
							this.y = clientY - this.startY;
                            this.constrain();
						},
						end(e) {
							this.panning = false;
							if (e.touches && e.touches.length < 2) {
								this.pinching = false;
							}
						},
						// Zoom to mouse logic (grahhh I love overengineering)
						zoom(e) {
                            const rect = this.$refs.viewport.getBoundingClientRect();
                            const mouseX = e.clientX - rect.left;
                            const mouseY = e.clientY - rect.top;

                            const oldScale = this.scale;
                            
							const factor = 0.1;
							const delta = e.deltaY < 0 ? 1 : -1;
							const newScaleRaw = oldScale + (delta * factor * oldScale);
							const newScale = Math.min(Math.max(0.2, newScaleRaw), 5);

                            // Calculate the point under the mouse in content space
                            const contentPointX = (mouseX - this.x) / oldScale;
                            const contentPointY = (mouseY - this.y) / oldScale;

                            // Calculate new x/y to keep contentPoint under mouse
                            this.x = mouseX - (contentPointX * newScale);
                            this.y = mouseY - (contentPointY * newScale);
                            
                            this.scale = newScale;
                            this.constrain();
						},
						zoomIn() {
							this.scale = Math.min(5, this.scale * 1.2);
                            this.constrain();
						},
						zoomOut() {
							this.scale = Math.max(0.2, this.scale / 1.2);
                            this.constrain();
						},
						reset() {
                            this.focusActiveMatch();
						}
					}))
				});
			</script>
		</div>
	}
}
